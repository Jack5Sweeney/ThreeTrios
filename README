The overall purpose of this codebase it to implement a card game, which is based off of
player interactions and different view updates. The project facilitates card-based gameplay where
components interact in harmony to create a playable and fun game. People that try to use this
codebase will need a basic understanding of java as well as being familiar with OOD design
principals. There are 3 interfaces where the classes all implement the interfaces that we created.
There are four enums that are used for the project which are a specific design choice.

An example of a quick setup/initialization would be :
    redPlayer = new model.PlayerImpl(model.PlayerColor.RED, new ArrayList<>());
    bluePlayer = new model.PlayerImpl(model.PlayerColor.BLUE, new ArrayList<>());
    players = new ArrayList<>(List.of(redPlayer, bluePlayer));
    model = new model.ModelImpl("board.config", "card.database", players);
and then model.startGame();

This demonstrates the setup of a model and players, and how to start a basic game.

Key Components:

Model (model.ModelImpl) : Manages the game's logic, handles the state, rules, and structure for cards
and players.

View (view.TextViewImpl) : This renders the view in a way that can be seen through a string version
of the game.

Player (model.PlayerImpl) : Represents individual players in the game, it has attributes like color
and score.

Key Subcomponents :

model.Direction and model.Direction value: These are important enums that determine the direction and
value of each card, which is vital for the model and logic of the game.

model.CellType: This is an enum which determines if the cell of the board is empty, a card, or a hole.
this is important for the board configuration and how the game can be played.

model.CardImpl: This class is for the creation of a card. The card has a player, a player name, and the
directions and the values that go with each direction.

model.PlayerColor: This is a simple enum that helps determine if it is either a red or blue player.

Class Invariants:
The board availability and board with cards arrays are consistent. For any position (i, j):
If boardAvailability[i][j] == model.CellType. CARD, then boardWithCards[i][j] != null.
If boardAvailability[i][j] != model.CellType. CARD, then boardWithCards[i][j] == null.

In the configBoardAvailability method the cells that are marked as model.CellType.EMPTY or
model.CellType.HOLE are set in boardAvailability without any cards in boardWithCards ensuring that non
model.CellType.CARD cells are null in the boardWithCards.

These are invariants because they are logical statements that occur consistently throughout
the model that have to be true for the board to work.

Source Org.

src : contains all the primary code files
    model.ModelImpl.java and model.IModel.java
    view.TextViewImpl.java and view.ITextView.java
    model.PlayerImpl.java and model.IPlayer.java
test/ : handles all the testing files for model and view


Changes for Part 2
In reexamining the model’s design and implementation from the previous assignment,
we identified a few areas that needed enhancements to improve gameplay functionality and user experience.
Below is a summary of the changes made, explaining what functionality was previously missing, the reasons behind it,
and how we addressed these issues.

1. Move Evaluation: calculateFlips
Missing Functionality: The original model lacked a method for evaluating the potential impact of a move before
executing it. Without a preview option, players couldn’t anticipate how many opponent cards their move might flip,
limiting strategic planning.

New Addition: We introduced calculateFlips, a method that calculates the number of opponent cards that would be flipped
if a player places a card at a specific position.

Implementation Details: The calculateFlips method examines the board in four cardinal directions
(North, South, East, West) using the helper function countFlipsInDirection to tally flips based on game rules.
This change allows players to preview move impacts without altering the board state, supporting more strategic decision-making.

2. Real-Time Score Tracking: getPlayerScore
Missing Functionality: The previous model didn’t offer real-time score tracking. As a result, the player’s score wasn’t
dynamically updated or displayed based on board state changes.

New Addition: We added getPlayerScore, a method that counts a player's cards on the board and returns the current score.

Implementation Details: getPlayerScore iterates over the board, identifying cards associated with the specified player.
This addition enables real-time score updates, enriching the competitive aspect of the game and giving players
immediate feedback on their progress.

3. Separation of File Management
Missing Functionality: File reading functionality was initially embedded within the model, reducing modularity and
compromising the model’s focus on game logic.

New Addition: File reading has been moved outside the model into a dedicated class, allowing the model to concentrate
on game-specific operations.

Implementation Details: By externalizing file reading, the model now better adheres to single-responsibility principles,
improving modularity and readability.

4. Enhanced Turn Management: getPlayerToPlace and getCardIndexToPlace
Missing Functionality: The model previously lacked a method to track a player’s current selection, complicating
the turn-by-turn logic.

New Addition: We added getPlayerToPlace and getCardIndexToPlace to the model interface to manage the current card selection.

Implementation Details: These methods keep track of the player’s intended card placement, streamlining
turn-taking and enhancing game flow consistency.

5. Read-Only Model Interface
Missing Functionality: Previously, the view had access to mutator methods, risking unintended modifications to the model.

New Addition: We created a ReadOnlyModel interface that exposes only observer methods to the view.

Implementation Details: By restricting the view to read-only access, this interface preserves the integrity of the
model state and aligns with MVC architecture best practices.