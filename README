The overall purpose of this codebase it to implement a card game, which is based off of
player interactions and different view updates. The project facilitates card-based gameplay where
components interact in harmony to create a playable and fun game. People that try to use this
codebase will need a basic understanding of java as well as being familiar with OOD design
principals. There are 3 interfaces where the classes all implement the interfaces that we created.
There are four enums that are used for the project which are a specific design choice.

An example of a quick setup/initialization would be :
    redPlayer = new model.PlayerImpl(model.PlayerColor.RED, new ArrayList<>());
    bluePlayer = new model.PlayerImpl(model.PlayerColor.BLUE, new ArrayList<>());
    players = new ArrayList<>(List.of(redPlayer, bluePlayer));
    model = new model.ModelImpl("board.config", "card.database", players);
and then model.startGame();

This demonstrates the setup of a model and players, and how to start a basic game.

Key Components:

Model (model.ModelImpl) : Manages the game's logic, handles the state, rules, and structure for cards
and players.

View (view.ViewImpl) : This renders the view in a way that can be seen through a string version
of the game.

Player (model.PlayerImpl) : Represents individual players in the game, it has attributes like color
and score.

Key Subcomponents :

model.Direction and model.Direction value: These are important enums that determine the direction and
value of each card, which is vital for the model and logic of the game.

model.CellType: This is an enum which determines if the cell of the board is empty, a card, or a hole.
this is important for the board configuration and how the game can be played.

model.CardImpl: This class is for the creation of a card. The card has a player, a player name, and the
directions and the values that go with each direction.

model.PlayerColor: This is a simple enum that helps determine if it is either a red or blue player.

Class Invariants:
The board availability and board with cards arrays are consistent. For any position (i, j):
If boardAvailability[i][j] == model.CellType. CARD, then boardWithCards[i][j] != null.
If boardAvailability[i][j] != model.CellType. CARD, then boardWithCards[i][j] == null.

In the configBoardAvailability method the cells that are marked as model.CellType.EMPTY or
model.CellType.HOLE are set in boardAvailability without any cards in boardWithCards ensuring that non
model.CellType.CARD cells are null in the boardWithCards.

These are invariants because they are logical statements that occur consistently throughout
the model that have to be true for the board to work.

Source Org.

src : contains all the primary code files
    model.ModelImpl.java and model.IModel.java
    view.ViewImpl.java and view.IView.java
    model.PlayerImpl.java and model.IPlayer.java
test/ : handles all the testing files for model and view


Changes for Part 2
To improve the model's functionality, we added two new methods: calculateFlips and getPlayerScore.

1. calculateFlips
Purpose: Calculates the number of opponent cards that would be flipped if a player places a card
at a specific position.
Reason: Previously, there was no way to evaluate a move's impact without executing it.
This method helps players strategize by previewing flips without altering the board state.
Implementation: calculateFlips checks in all four directions (North, South, East, West)
using a helper method, countFlipsInDirection, to tally flips based on game rules.
2. getPlayerScore
Purpose: Returns the current score of a player by counting their cards on the board.
Reason: The previous model lacked a way to track and display player scores dynamically.
This addition enables real-time score updates.
Implementation: getPlayerScore iterates over the board to count cards belonging to the
specified player.

