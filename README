The overall purpose of this codebase it to implement a card game, which is based off of
player interactions and different view updates. The project facilitates card-based gameplay where
components interact in harmony to create a playable and fun game. People that try to use this
codebase will need a basic understanding of java as well as being familiar with OOD design
principals. There are 3 interfaces where the classes all implement the interfaces that we created.
There are four enums that are used for the project which are a specific design choice.

An example of a quick setup/initialization would be :
    PlayerImpl redPlayer = new PlayerImpl(PlayerColor.RED, new ArrayList<>());
    PlayerImpl bluePlayer = new PlayerImpl(PlayerColor.BLUE, new ArrayList<>());
    ArrayList<IPlayer> players = new ArrayList<>(List.of(redPlayer, bluePlayer));

    ConfigGame gameConfigurator = new ConfigGame("board.config", "card.database");
    ModelImpl model = new ModelImpl(gameConfigurator.getBoard(), gameConfigurator.getDeck(), players);
    ReadOnlyIModel readOnlyModel = new ModelImpl(gameConfigurator.getBoard(), gameConfigurator.getDeck(), players);

    ControllerGUIImpl controller = new ControllerGUIImpl(readOnlyModel);
    controller.playGame(model);

This demonstrates the setup of a model and players, and how to start a basic game.

Key Components:

Model (model.ModelImpl) : Manages the game's logic, handles the state, rules, and structure for cards
and players.

View (view.TextViewImpl) : This renders the view in a way that can be seen through a string version
of the game.

Player (model.PlayerImpl) : Represents individual players in the game, it has attributes like color
and score.

Key Subcomponents :

model.Direction and model.Direction value: These are important enums that determine the direction and
value of each card, which is vital for the model and logic of the game.

model.CellType: This is an enum which determines if the cell of the board is empty, a card, or a hole.
this is important for the board configuration and how the game can be played.

model.CardImpl: This class is for the creation of a card. The card has a player, a player name, and the
directions and the values that go with each direction.

model.PlayerColor: This is a simple enum that helps determine if it is either a red or blue player.

Class Invariants:
The board availability and board with cards arrays are consistent. For any position (i, j):
If boardAvailability[i][j] == model.CellType. CARD, then boardWithCards[i][j] != null.
If boardAvailability[i][j] != model.CellType. CARD, then boardWithCards[i][j] == null.

In the configBoardAvailability method the cells that are marked as model.CellType.EMPTY or
model.CellType.HOLE are set in boardAvailability without any cards in boardWithCards ensuring that non
model.CellType.CARD cells are null in the boardWithCards.

These are invariants because they are logical statements that occur consistently throughout
the model that have to be true for the board to work.

Source Org.

src : contains all the primary code files
    model.ModelImpl.java and model.IModel.java
    view.TextViewImpl.java and view.ITextView.java
    model.PlayerImpl.java and model.IPlayer.java
test/ : handles all the testing files for model and view

Coordinate System:
The game board is represented as a 2D array, where each element corresponds to a cell on the board.
The coordinate system uses a row-major order, meaning that the first index represents the row (y-coordinate),
and the second index represents the column (x-coordinate).

Origin: The origin of the grid is located at the top-left corner, with coordinates (0, 0).
Row and Column Indices:

board[row][col]: Here, row specifies the vertical position (moving downward increases the row index),
and col specifies the horizontal position (moving right increases the column index).

Changes for Part 2
In reexamining the model’s design and implementation from the previous assignment,
we identified a few areas that needed enhancements to improve gameplay functionality and user experience.
Below is a summary of the changes made, explaining what functionality was previously missing, the reasons behind it,
and how we addressed these issues.

1. Move Evaluation: calculateFlips
Missing Functionality: The original model lacked a method for evaluating the potential impact of a move before
executing it. Without a preview option, players couldn’t anticipate how many opponent cards their move might flip,
limiting strategic planning.

New Addition: We introduced calculateFlips, a method that calculates the number of opponent cards that would be flipped
if a player places a card at a specific position.

Implementation Details: The calculateFlips method examines the board in four cardinal directions
(North, South, East, West) using the helper function countFlipsInDirection to tally flips based on game rules.
This change allows players to preview move impacts without altering the board state, supporting more strategic decision-making.

2. Real-Time Score Tracking: getPlayerScore
Missing Functionality: The previous model didn’t offer real-time score tracking. As a result, the player’s score wasn’t
dynamically updated or displayed based on board state changes.

New Addition: We added getPlayerScore, a method that counts a player's cards on the board and returns the current score.

Implementation Details: getPlayerScore iterates over the board, identifying cards associated with the specified player.
This addition enables real-time score updates, enriching the competitive aspect of the game and giving players
immediate feedback on their progress.

3. Separation of File Management
Missing Functionality: File reading functionality was initially embedded within the model, reducing modularity and
compromising the model’s focus on game logic.

New Addition: File reading has been moved outside the model into a dedicated class, allowing the model to concentrate
on game-specific operations.

Implementation Details: By externalizing file reading, the model now better adheres to single-responsibility principles,
improving modularity and readability.

4. Enhanced Turn Management: getPlayerToPlace and getCardIndexToPlace
Missing Functionality: The model previously lacked a method to track a player’s current selection, complicating
the turn-by-turn logic.

New Addition: We added getPlayerToPlace and getCardIndexToPlace to the model interface to manage the current card selection.

Implementation Details: These methods keep track of the player’s intended card placement, streamlining
turn-taking and enhancing game flow consistency.

5. Read-Only Model Interface
Missing Functionality: Previously, the view had access to mutator methods, risking unintended modifications to the model.

New Addition: We created a ReadOnlyModel interface that exposes only observer methods to the view.

Implementation Details: By restricting the view to read-only access, this interface preserves the integrity of the
model state and aligns with MVC architecture best practices.

6. Removing Concrete Class-types From Model Implementation:
To improve flexibility and adherence to interface-based design principles,
we removed concrete class references within the model implementation wherever possible.
Instead of directly using specific class types like PlayerImpl or CardImpl,
we rely on interfaces (IPlayer, ICard)

7. After implementing calculateFlips correctly, this allowed for the strategies to be made.
The first strategy we made was the FlipTheMostStrategy, which placed cards where they would flip
the most cards, an aggressive strategy to flip the most possible, where we used calculateFlips to
find the max amount of cards we could flip with the projected placement of a card in the spot of
the board.
The second strategy we made was the CornerStrategy, this picked the corners first, and once the
corners are placed it picks the uppermost leftmost placement. This strategy is defensive because it
picks the cards that are harder to flip and puts them in the corner.

8. We made mock classes for testing purposes.